{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', () => {
  // START: Add missing global helper functions
  // Note: These functions are likely intended for a global script or base.html
  // to be available on all pages. They are added here to resolve the error.
  
  // A simple implementation for a loader overlay.
  // Assumes you have an element like <div id="loader-overlay" class="hidden">...</div> in your base HTML.
  window.showLoader = () => {
    const loader = document.querySelector('#loader-overlay'); // Using a general selector
    if (loader) loader.classList.remove('hidden');
  };

  window.hideLoader = () => {
    const loader = document.querySelector('#loader-overlay');
    if (loader) loader.classList.add('hidden');
  };

  // A simple implementation for a custom alert.
  // Assumes you have an alert element in your base HTML.
  window.showAlert = (message) => {
    console.log(`Alert: ${message}`);
    alert(message); // Fallback to the browser's default alert
  };
  // END: Add missing global helper functions
  // === DOM Elements ===
  const calendarGrid = document.getElementById('calendar-grid');
  const currentMonthYearDisplay = document.getElementById('current-month-year');
  const prevMonthBtn = document.getElementById('prev-month-btn');
  const nextMonthBtn = document.getElementById('next-month-btn');
  const dailyScheduleContainer = document.getElementById('daily-schedule-container');
  const scheduleDateDisplay   = document.getElementById('schedule-date');
  const scheduleSlotsContainer= document.getElementById('schedule-slots');
  const eventDetailsContainer = document.getElementById('event-details-container');
  const createEventView       = document.getElementById('create-event-view');
  const viewEventAvailable    = document.getElementById('view-event-available');
  const viewEventFull         = document.getElementById('view-event-full');
  const instructionBubble     = document.getElementById('instruction-bubble');
  const durationOptions       = document.getElementById('duration-options');
  const createEventBtn        = document.getElementById('create-event-submit-btn');
  const signupEventBtn        = document.getElementById('signup-event-btn');
  const courtTypeOptions      = document.getElementById('court-type-options');
  const minParticipantsInput  = document.getElementById('min-participants');

  // === State ===
  let currentDate = new Date();
  let selectedDate = null;
  let selectedTimeSlot = null;
  let selectedDuration = null; // 이 변수는 paintSelectionRange를 위해 유지됩니다.
  let selectedEventId = null;
  let selectedCourtType = 'half'; // Default court type

  // === Selection Paint Helpers ===
  function clearSelectionPaint() {
    if (!scheduleSlotsContainer) return;
    scheduleSlotsContainer
      .querySelectorAll('.slot-select-overlay')
      .forEach(el => el.remove());
    scheduleSlotsContainer
      .querySelectorAll('.time-slot.slot-selected')
      .forEach(el => el.classList.remove('slot-selected'));
  }

  function minutesFromHHMM(hhmm) {
    if (!hhmm) return null;
    const [h, m] = hhmm.split(':').map(Number);
    return h * 60 + m;
  }

  function paintSelectionRange(startHHMM, durationMin) {
    if (!scheduleSlotsContainer || !startHHMM || !durationMin) return;
    clearSelectionPaint();

    const startMin = minutesFromHHMM(startHHMM);
    const endMin = startMin + Number(durationMin);

    for (let m = startMin; m < endMin; m += 30) {
      const hh = String(Math.floor(m / 60)).padStart(2, '0');
      const mm = String(m % 60).padStart(2, '0');
      const slot = scheduleSlotsContainer.querySelector(`.time-slot[data-time="${hh}:${mm}"]`);
      if (!slot || slot.dataset.type !== 'empty') continue;

      const isOnTheHour = slot.classList.contains('border-t-2');
      const topGapPx = isOnTheHour ? 2 : 1;

      if (slot.querySelector('.slot-select-overlay')) continue;

      const overlay = document.createElement('div');
      overlay.className = 'slot-select-overlay pointer-events-none absolute left-0 right-0 rounded-md';
      overlay.style.top = `${topGapPx}px`;
      overlay.style.bottom = '0px';
      overlay.style.backgroundColor = 'rgba(74, 222, 128, 0.25)';
      if (getComputedStyle(slot).position === 'static') {
        slot.style.position = 'relative';
      }
      slot.appendChild(overlay);
      slot.classList.add('slot-selected');
    }
  }

  // === UI Rendering ===
  async function renderCalendar(date) {
    if (!calendarGrid || !currentMonthYearDisplay) return;
    calendarGrid.innerHTML = '';
    const year = date.getFullYear();
    const month = date.getMonth();
    currentMonthYearDisplay.textContent = `${year}년 ${month + 1}월`;

    let eventDatesSet = new Set();
    try {
      const response = await window.authedFetch(`/api/events/summary?year=${year}&month=${month + 1}`);
      if (response.ok) {
        const data = await response.json();
        eventDatesSet = new Set(data.dates_with_events);
      } else {
        console.error("Failed to fetch event summary");
      }
    } catch (error) {
      if (error.message !== 'Unauthorized') {
        console.error("Error fetching event summary:", error);
      }
    }

    const firstDayOfMonth = new Date(year, month, 1).getDay();
    const lastDateOfMonth = new Date(year, month + 1, 0).getDate();

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    for (let day = 1; day <= lastDateOfMonth; day++) {
      const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
      const currentDateInLoop = new Date(dateStr);
      const isToday = (currentDateInLoop.getTime() === today.getTime());
      const isPast = currentDateInLoop < today;
      const hasEvent = eventDatesSet.has(dateStr);

      let cellClasses = 'date-cell h-12 flex items-center justify-center cursor-pointer rounded-lg transition-colors duration-150 focus:outline-none focus-visible:ring-2 focus-visible:ring-emerald-500 text-gray-700';

      if (dateStr === selectedDate) {
        cellClasses += ' bg-emerald-600 text-white font-bold';
      } else if (isToday) {
        cellClasses += ' bg-emerald-500 text-white font-bold shadow-sm is-today';
      } else if (hasEvent && !isPast) {
        cellClasses += ' bg-gray-200 font-semibold hover:bg-gray-300';
      } else {
        cellClasses += ' hover:bg-gray-100';
      }

      const cell = `<div class="${cellClasses}" data-date="${dateStr}" tabindex="0" role="button" aria-label="${day}일"> ${day} </div>`;
      calendarGrid.insertAdjacentHTML('beforeend', cell);
    }
  }

  async function renderDailySchedule(dateStr) {
    window.showLoader();
    const [year, month, day] = dateStr.split('-');
    if (scheduleDateDisplay) scheduleDateDisplay.textContent = `${year}년 ${month}월 ${day}일`;

    try {
      const response = await window.authedFetch(`/api/events?date=${dateStr}`);
      if (!response.ok) throw new Error('일정 데이터를 불러오지 못했습니다.');
      const data = await response.json();
      const events = data.events || [];

      const eventMap = new Map();
      events.forEach(event => {
        const startTime = event.time;
        for (let i = 0; i < event.duration; i += 30) {
          const slotDate = new Date(`${dateStr}T${startTime}:00`);
          slotDate.setMinutes(slotDate.getMinutes() + i);
          const slotTime = `${String(slotDate.getHours()).padStart(2, '0')}:${String(slotDate.getMinutes()).padStart(2, '0')}`;
          
          // Allow multiple half-court events in the same slot
          if (!eventMap.has(slotTime)) {
            eventMap.set(slotTime, []);
          }
          eventMap.get(slotTime).push({ isStart: i === 0, event });
        }
      });

      scheduleSlotsContainer.innerHTML = '';
      for (let hour = 8; hour < 22; hour++) {
        for (let minute = 0; minute < 60; minute += 30) {
          const timeStr = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
          const slotEventsInfo = eventMap.get(timeStr);

          const borderClass = minute === 0 ? 'border-t-2 border-gray-400' : 'border-t border-dashed border-gray-300';
          let slotHtml = '';

          if (slotEventsInfo) {
            // If there's a full court event, it takes the whole slot
            const fullCourtEventInfo = slotEventsInfo.find(info => info.event.court_type === 'full');
            if (fullCourtEventInfo) {
                const event = fullCourtEventInfo.event;
                const isFull = event.current >= event.max;
                const slotClass = isFull ? 'bg-pink-300 text-white' : 'bg-green-300 text-white';
                const slotType = isFull ? 'full' : 'available';
                let slotText = '&nbsp;';
                if (fullCourtEventInfo.isStart) {
                    slotText = `${timeStr} [풀] · ${event.current} / ${event.max}명`;
                }
                slotHtml = `
                    <div class="time-slot h-10 flex items-center px-3 text-sm ${borderClass} ${slotClass} cursor-pointer transition-colors duration-150"
                         data-time="${timeStr}" data-type="${slotType}" data-event='${JSON.stringify(event)}' tabindex="0">
                        ${slotText}
                    </div>`;
            } else { // Handle half-court events
                let eventDivs = '';
                for (const info of slotEventsInfo) {
                    const event = info.event;
                    const isFull = event.current >= event.max;
                    const slotClass = isFull ? 'bg-pink-200 text-white' : 'bg-green-200 text-white';
                    const slotType = isFull ? 'full' : 'available';
                    let slotText = '&nbsp;';
                     if (info.isStart) {
                        slotText = `${timeStr} [하프] ${event.current}/${event.max}`;
                    }
                    eventDivs += `
                        <div class="time-slot flex-1 h-full flex items-center justify-center text-xs ${slotClass} cursor-pointer"
                             data-time="${timeStr}" data-type="${slotType}" data-event='${JSON.stringify(event)}' tabindex="0">
                             ${slotText}
                        </div>`;
                }
                // Empty slot for new half-court game
                if (slotEventsInfo.length < 2) {
                   eventDivs += `<div class="time-slot flex-1 h-full flex items-center justify-center text-xs bg-gray-200 hover:bg-gray-300 text-gray-600 cursor-pointer"
                                     data-time="${timeStr}" data-type="empty" data-event='{}' tabindex="0">${timeStr}</div>`;
                }
                 slotHtml = `<div class="h-10 flex ${borderClass}">${eventDivs}</div>`;
            }
          } else {
             slotHtml = `
              <div class="time-slot h-10 flex items-center px-3 text-sm ${borderClass} bg-gray-200 hover:bg-gray-300 text-gray-600 cursor-pointer transition-colors duration-150"
                   data-time="${timeStr}" data-type="empty" data-event='{}' tabindex="0">
                ${timeStr}
              </div>`;
          }
          scheduleSlotsContainer.insertAdjacentHTML('beforeend', slotHtml);
        }
      }

      const durationSelectedInput = document.getElementById('duration-selected');
      if (createEventView && !createEventView.classList.contains('hidden') && selectedTimeSlot && durationSelectedInput?.value) {
        paintSelectionRange(selectedTimeSlot, durationSelectedInput.value);
      }
    } catch (error) {
      if (error.message !== 'Unauthorized') {
        window.showAlert("일정을 불러오는 데 실패했습니다. 다시 시도해 주세요.");
      }
    } finally {
      window.hideLoader();
    }
  }

  function showEventDetailView(viewToShow) {
    if (!createEventView || !viewEventAvailable || !viewEventFull || !eventDetailsContainer || !instructionBubble) return;
    createEventView.classList.add('hidden');
    viewEventAvailable.classList.add('hidden');
    viewEventFull.classList.add('hidden');
    const shouldShowDetails = viewToShow !== 'none';
    eventDetailsContainer.classList.toggle('hidden', !shouldShowDetails);
    instructionBubble.classList.toggle('hidden', shouldShowDetails);
    if (shouldShowDetails) {
      if (viewToShow === 'create')   createEventView.classList.remove('hidden');
      if (viewToShow === 'available')viewEventAvailable.classList.remove('hidden');
      if (viewToShow === 'full')     viewEventFull.classList.remove('hidden');
    }
    if (viewToShow !== 'create') {
      clearSelectionPaint();
    }
  }

  function formatKoreanDate(dateStr) {
    const [y, m, d] = dateStr.split('-');
    return `${y}년 ${m}월 ${d}일`;
  }

  async function handleDateClick(e) {
    const cell = e.target.closest('.date-cell');
    if (!cell) return;
    selectedDate = cell.dataset.date;
    selectedTimeSlot = null;
    selectedDuration = null;
    clearSelectionPaint();
    await renderCalendar(currentDate);
    if (dailyScheduleContainer) dailyScheduleContainer.classList.remove('hidden');
    showEventDetailView('none');
    await renderDailySchedule(selectedDate);
  }

  function handleTimeSlotClick(e) {
    const slot = e.target.closest('.time-slot');
    if (!slot) return;
    selectedTimeSlot = slot.dataset.time;
    const slotType = slot.dataset.type;
    const eventData = JSON.parse(slot.dataset.event || '{}');
    selectedEventId = eventData.id || null;

    if (slotType === 'empty') {
      clearSelectionPaint();
      showEventDetailView('create');
      const dt = document.getElementById('create-event-date-time');
      if (dt) dt.textContent = `${formatKoreanDate(selectedDate)} ${selectedTimeSlot}`;

      // This logic needs adjustment for half/full court conflicts, but for now we focus on creation UI
      // The backend will perform the definitive validation.
      const availableMinutes = 4 * 60; // Assume max availability, backend validates
      document.querySelectorAll('.duration-btn').forEach(btn => {
        const duration = parseInt(btn.dataset.duration, 10);
        const disabled = duration > availableMinutes;
        btn.disabled = disabled;
        btn.classList.toggle('opacity-40', disabled);
        btn.classList.toggle('cursor-not-allowed', disabled);
      });

      selectedDuration = null;
      document.querySelectorAll('.duration-btn').forEach(b => b.classList.remove('bg-emerald-500', 'text-white'));

      const DEFAULT_DURATION = 60;
      if (DEFAULT_DURATION <= availableMinutes) {
        selectedDuration = DEFAULT_DURATION;
        const defaultDurationBtn = document.querySelector(`.duration-btn[data-duration="${DEFAULT_DURATION}"]`);
        if (defaultDurationBtn) {
           defaultDurationBtn.click(); // Use click to trigger selection style
        }
        paintSelectionRange(selectedTimeSlot, selectedDuration);
      }

    } else {
      const endTime = new Date(`${selectedDate}T${eventData.time}`);
      endTime.setMinutes(endTime.getMinutes() + eventData.duration);
      const endTimeStr = `${String(endTime.getHours()).padStart(2, '0')}:${String(endTime.getMinutes()).padStart(2, '0')}`;
      const timeDisplay = `${eventData.time} - ${endTimeStr} (${eventData.duration}분)`;
      const participantsDisplay = `${eventData.current}명 / ${eventData.max}명`;
      const creatorIdDisplay = eventData.creator?.id ?? '';
      const creatorContactDisplay = eventData.creator?.phone ?? '';
      const dateDisplay = formatKoreanDate(selectedDate);
      const courtTypeDisplay = (eventData.court_type === 'full') ? '풀 코트' : '하프 코트';

      if (slotType === 'available') {
        showEventDetailView('available');
        document.getElementById('view-available-date').textContent = dateDisplay;
        document.getElementById('view-available-time').textContent = timeDisplay;
        document.getElementById('view-available-court-type').textContent = courtTypeDisplay;
        document.getElementById('view-available-participants').textContent = participantsDisplay;
        document.getElementById('view-available-creator-id').textContent = creatorIdDisplay;
        document.getElementById('view-available-creator-contact').textContent = creatorContactDisplay;
      } else if (slotType === 'full') {
        showEventDetailView('full');
        document.getElementById('view-full-date').textContent = dateDisplay;
        document.getElementById('view-full-time').textContent = timeDisplay;
        document.getElementById('view-full-court-type').textContent = courtTypeDisplay;
        document.getElementById('view-full-participants').textContent = participantsDisplay;
        document.getElementById('view-full-creator-id').textContent = creatorIdDisplay;
        document.getElementById('view-full-creator-contact').textContent = creatorContactDisplay;
      }
    }
  }

  async function handleCreateEvent() {
    const createBtn = document.getElementById('create-event-submit-btn');
    const originalBtnText = '생성하기';
    const description = document.getElementById('event-description').value;
    const durationSelectedInput = document.getElementById('duration-selected');
    const currentSelectedDuration = durationSelectedInput ? durationSelectedInput.value : null;
    const minParticipants = document.getElementById('min-participants').value;
    const maxParticipants = document.getElementById('max-participants').value;

    if (!selectedDate || !selectedTimeSlot || !currentSelectedDuration) {
      return window.showAlert("날짜, 시간, 진행 시간을 선택해주세요.");
    }
    if (!description.trim()) {
      return window.showAlert("모임 설명을 입력해주세요.");
    }

    if (+minParticipants > +maxParticipants)
      return window.showAlert("최소 인원은 최대 인원보다 많을 수 없습니다.");
    if (+minParticipants <= 0 || +maxParticipants <= 0)
      return window.showAlert("참여 인원은 1명 이상이어야 합니다.");

    window.showLoader();
    createBtn.disabled = true;
    createBtn.textContent = '처리 중...';

    try {
      const response = await window.authedFetch('/api/events', {
        method: 'POST',
        body: JSON.stringify({
          date: selectedDate,
          time: selectedTimeSlot,
          duration: parseInt(currentSelectedDuration),
          min_participants: parseInt(minParticipants),
          max_participants: parseInt(maxParticipants),
          court_type: selectedCourtType // Add court type to request
        })
      });
      const result = await response.json();
      if (response.ok) {
        window.showAlert(result.message);
        showEventDetailView('none');
        await renderDailySchedule(selectedDate);
        await renderCalendar(currentDate);
        document.getElementById('event-description').value = '';
      } else {
        window.showAlert(result.message || "모임 생성에 실패했습니다.");
      }
    } catch (error) {
      if (error.message !== 'Unauthorized') window.showAlert("모임 생성에 실패했습니다.");
    } finally {
      window.hideLoader();
      createBtn.disabled = false;
      createBtn.textContent = originalBtnText;
    }
  }

  async function handleSignupEvent() {
    if (!selectedEventId) return window.showAlert("선택된 모임이 없습니다.");
    window.showLoader();
    try {
      const response = await window.authedFetch(`/api/events/${selectedEventId}/signup`, { method: 'POST' });
      const result = await response.json();
      if (response.ok) {
        window.showAlert(result.message);
        showEventDetailView('none');
        await renderDailySchedule(selectedDate);
        await renderCalendar(currentDate);
      } else {
        window.showAlert(result.message || "참가 신청에 실패했습니다.");
      }
    } catch (error) {
      if (error.message !== 'Unauthorized') window.showAlert("참가 신청에 실패했습니다.");
    } finally {
      window.hideLoader();
    }
  }
	 // === Logic from event_details.html (consolidated here) ===
  function validateParticipants() {
      if (!minParticipantsInput || !maxParticipantsInput) return true;
      const min = parseInt(minParticipantsInput.value || '0', 10);
      const max = parseInt(maxParticipantsInput.value || '0', 10);
      const isInvalid = Number.isFinite(min) && Number.isFinite(max) && max < min;

      [minParticipantsInput, maxParticipantsInput].forEach(el => {
        el.classList.toggle('border-red-400', isInvalid);
        el.classList.toggle('focus:ring-red-400', isInvalid);
      });
      if (participantsHelpText) {
        participantsHelpText.classList.toggle('text-red-600', isInvalid);
        participantsHelpText.classList.toggle('text-gray-500', !isInvalid);
      }
      return !isInvalid;
  }


  // === WebSocket Listener ===
  const onWsMessage = async (event) => {
    try {
      const data = JSON.parse(event.data);
      if (data.type === 'event_update') {
        const eventDate = new Date(data.date);
        if (eventDate.getFullYear() === currentDate.getFullYear() && eventDate.getMonth() === currentDate.getMonth()) {
          await renderCalendar(currentDate);
        }
        if (data.date === selectedDate) {
          await renderDailySchedule(selectedDate);
        }
      }
    } catch (_) {}
  };

  // === INITIALIZATION ===
  const init = async () => {
    window.showLoader();
    try {
      if (prevMonthBtn) prevMonthBtn.addEventListener('click', () => { currentDate.setMonth(currentDate.getMonth() - 1); renderCalendar(currentDate); });
      if (nextMonthBtn) nextMonthBtn.addEventListener('click', () => { currentDate.setMonth(currentDate.getMonth() + 1); renderCalendar(currentDate); });
      if (calendarGrid) calendarGrid.addEventListener('click', handleDateClick);
      if (scheduleSlotsContainer) scheduleSlotsContainer.addEventListener('click', handleTimeSlotClick);
      if (createEventBtn) createEventBtn.addEventListener('click', handleCreateEvent);
      if (signupEventBtn) signupEventBtn.addEventListener('click', handleSignupEvent);

      // event_details.html의 보조 스크립트가 시각적 처리를 담당하므로,
      // 메인 스크립트는 상태 업데이트 및 재그리기만 담당합니다.
      if (durationOptions) {
        durationOptions.addEventListener('click', (e) => {
          const btn = e.target.closest('.duration-btn');
          if (!btn || btn.disabled) return;
          // This logic is now handled by the separate script in event_details.html
          selectedDuration = btn.dataset.duration;

          if (selectedTimeSlot) {
            paintSelectionRange(selectedTimeSlot, selectedDuration);
          }
        });
      }

      // START: Add court type selection logic
      if (courtTypeOptions) {
          courtTypeOptions.addEventListener('click', (e) => {
              const btn = e.target.closest('.court-type-btn');
              if (!btn) return;
              
              document.querySelectorAll('.court-type-btn').forEach(b => {
                  b.classList.remove('bg-emerald-500', 'text-white');
                  b.classList.add('bg-white', 'text-gray-700');
                  b.setAttribute('aria-pressed', 'false');
              });
              btn.classList.add('bg-emerald-500', 'text-white');
              btn.classList.remove('bg-white', 'text-gray-700');
              btn.setAttribute('aria-pressed', 'true');
              selectedCourtType = btn.dataset.courtType;

              if (selectedCourtType === 'full') {
                  minParticipantsInput.value = '10';
                  minParticipantsInput.min = '10';
                  // Dispatch input event to trigger validation check from event_details.html script
                   document.getElementById('max-participants').dispatchEvent(new Event('input'));
              } else { // half
                  minParticipantsInput.value = '2';
                  minParticipantsInput.min = '1';
              }
          });
      }
      // END: Add court type selection logic

      window.connectWebSocket();
      window.addEventListener('ws:open', () => {
        if (window.ws) window.ws.addEventListener('message', onWsMessage);
      });
      if (window.ws && window.ws.readyState === WebSocket.OPEN) {
        window.ws.addEventListener('message', onWsMessage);
      }

      const today = new Date();
      selectedDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

      await renderCalendar(currentDate);
      await renderDailySchedule(selectedDate);

      if (dailyScheduleContainer) dailyScheduleContainer.classList.remove('hidden');
      showEventDetailView('none');

    } catch (error) {
      if (error.message !== 'Unauthorized') {
        console.error("Initialization failed:", error);
        window.showAlert("페이지 초기화에 실패했습니다.");
      }
    } finally {
      window.hideLoader();
    }
  };

  init();
});
</script>
{% endblock %}